"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/team/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: function() { return /* binding */ api; },\n/* harmony export */   listPlayers: function() { return /* binding */ listPlayers; },\n/* harmony export */   optimizeSquad: function() { return /* binding */ optimizeSquad; },\n/* harmony export */   squadSummary: function() { return /* binding */ squadSummary; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\nconst API_URL = \"http://localhost:8000/api/v1\" || 0;\nconsole.log(\"API URL:\", API_URL); // Debug log\nconst client = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    },\n    timeout: 60000\n});\n// Add request interceptor for debugging (only in dev)\nif (true) {\n    client.interceptors.request.use((config)=>{\n        var _config_method;\n        console.log(\"API Request:\", (_config_method = config.method) === null || _config_method === void 0 ? void 0 : _config_method.toUpperCase(), config.url);\n        return config;\n    }, (error)=>{\n        console.error(\"API Request Error:\", error);\n        return Promise.reject(error);\n    });\n    // Add response interceptor for debugging\n    client.interceptors.response.use((response)=>{\n        console.log(\"API Response:\", response.status, response.config.url);\n        return response;\n    }, (error)=>{\n        var _error_response_data, _error_response, _error_response_data1, _error_response1, _error_response2;\n        // Only log non-network errors in detail\n        if (error.code !== \"ERR_NETWORK\" && error.code !== \"ERR_CONNECTION_REFUSED\") {\n            var _error_response3, _error_config;\n            console.error(\"API Response Error:\", error.message, (_error_response3 = error.response) === null || _error_response3 === void 0 ? void 0 : _error_response3.status, (_error_config = error.config) === null || _error_config === void 0 ? void 0 : _error_config.url);\n        }\n        // Extract error message from response if available\n        if ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.detail) {\n            error.message = error.response.data.detail;\n        } else if ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data1 = _error_response1.data) === null || _error_response_data1 === void 0 ? void 0 : _error_response_data1.message) {\n            error.message = error.response.data.message;\n        } else if ((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.statusText) {\n            error.message = \"\".concat(error.response.status, \": \").concat(error.response.statusText);\n        }\n        return Promise.reject(error);\n    });\n}\nconst api = {\n    // Dashboard\n    async getDashboardStats () {\n        try {\n            const response = await client.post(\"/team/evaluate\", {\n                season: \"2024-25\"\n            }, {\n                timeout: 15000\n            });\n            return response.data;\n        } catch (error) {\n            var _error_message, _error_message1, _error_message2;\n            console.error(\"API Error:\", error);\n            // Return default data on network errors instead of throwing\n            const isNetworkError = error.code === \"ECONNABORTED\" || error.code === \"ERR_NETWORK\" || error.code === \"ERR_CONNECTION_REFUSED\" || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"timeout\")) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"Network Error\")) || ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"Failed to fetch\"));\n            if (isNetworkError) {\n                // Silently return default data for network errors\n                return {\n                    season: \"2024-25\",\n                    gameweek: null,\n                    total_points: 0.0,\n                    expected_points: 0.0,\n                    risk_score: 0.5,\n                    fixture_difficulty: 3.0,\n                    squad_value: 0.0,\n                    bank: 100.0,\n                    players: [],\n                    captain_id: null,\n                    vice_captain_id: null\n                };\n            }\n            throw error;\n        }\n    },\n    // Team\n    async evaluateTeam (data) {\n        try {\n            // Use longer timeout for team evaluation (30 seconds)\n            const response = await client.post(\"/team/evaluate\", data, {\n                timeout: 30000\n            });\n            if (true) {\n                console.log(\"Team evaluation response:\", response.status, response.data);\n            }\n            return response.data;\n        } catch (error) {\n            var _error_message, _error_message1, _error_message2;\n            // Check if it's a network error\n            const isNetworkError = error.code === \"ECONNABORTED\" || error.code === \"ERR_NETWORK\" || error.code === \"ERR_CONNECTION_REFUSED\" || ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"timeout\")) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes(\"Network Error\")) || ((_error_message2 = error.message) === null || _error_message2 === void 0 ? void 0 : _error_message2.includes(\"Failed to fetch\"));\n            if (isNetworkError) {\n                // Return placeholder data for network errors\n                return {\n                    total_points: 0,\n                    expected_points: 0,\n                    squad_value: 0,\n                    bank: 100,\n                    players: [],\n                    captain_id: null,\n                    vice_captain_id: null,\n                    xg_score: 0,\n                    risk_score: 0.5,\n                    fixture_difficulty: 3.0\n                };\n            }\n            // Only log non-network errors\n            if (true) {\n                var _error_response, _error_response1, _error_config;\n                console.error(\"Team evaluation error details:\", {\n                    message: error.message,\n                    code: error.code,\n                    response: (_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data,\n                    status: (_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status,\n                    config: (_error_config = error.config) === null || _error_config === void 0 ? void 0 : _error_config.url\n                });\n            }\n            throw error;\n        }\n    },\n    async getXGScore (data) {\n        const response = await client.post(\"/team/xgscore\", data);\n        return response.data;\n    },\n    // Optimization\n    async optimizeSquad (data) {\n        // Use longer timeout for optimization (60 seconds)\n        const response = await client.post(\"/optimize/squad\", data, {\n            timeout: 60000\n        });\n        return response.data;\n    },\n    // Transfers\n    async getTradeAdvice (data) {\n        const response = await client.post(\"/trades/advice\", data);\n        return response.data;\n    },\n    // Copilot\n    async askCopilot (question, options) {\n        const apiUrl = \"http://localhost:8000/api/v1\" || 0;\n        try {\n            const response = await fetch(\"\".concat(apiUrl, \"/api/v1/copilot/chat\"), {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    message: question,\n                    conversation_id: options === null || options === void 0 ? void 0 : options.conversation_id,\n                    team_id: options === null || options === void 0 ? void 0 : options.team_id,\n                    user_id: options === null || options === void 0 ? void 0 : options.user_id,\n                    route: (options === null || options === void 0 ? void 0 : options.route) || window.location.pathname,\n                    app_state: (options === null || options === void 0 ? void 0 : options.app_state) || {}\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Copilot endpoint failed: \".concat(response.status));\n            }\n            return response.json();\n        } catch (err) {\n            console.error(\"Copilot error:\", err);\n            throw err;\n        }\n    },\n    // ML Predictions\n    async predictPoints (data) {\n        const response = await client.post(\"/ml/predict\", data);\n        return response.data;\n    }\n};\n// Standalone function: List players\nasync function listPlayers(position) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const params = new URLSearchParams();\n    if (position) params.append(\"position\", position);\n    if (options.season) params.append(\"season\", options.season);\n    if (options.limit) params.append(\"limit\", String(options.limit));\n    if (options.offset) params.append(\"offset\", String(options.offset));\n    if (options.team) params.append(\"team\", options.team);\n    if (options.search) params.append(\"search\", options.search);\n    const response = await client.get(\"/players/?\".concat(params.toString()));\n    const players = Array.isArray(response.data) ? response.data : [];\n    return {\n        players,\n        total: players.length\n    };\n}\n// Standalone function: Optimize squad\nasync function optimizeSquad(data) {\n    return api.optimizeSquad(data);\n}\n// Standalone function: Squad summary (uses team evaluation endpoint)\nasync function squadSummary(data) {\n    // Create squad_json from xi_ids and bench_ids\n    const squad_json = {\n        xi: data.xi_ids,\n        bench: data.bench_ids\n    };\n    const response = await client.post(\"/team/evaluate\", {\n        season: data.season,\n        squad_json\n    });\n    return response.data;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEtBQUtNLE1BQU07UUFDbkJ3RDtJQUNGO0lBRUEsT0FBT2xFLFNBQVNJLElBQUk7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hcGkudHM/MmZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5cbmNvbnN0IEFQSV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaS92MVwiO1xuXG5jb25zb2xlLmxvZyhcIkFQSSBVUkw6XCIsIEFQSV9VUkwpOyAvLyBEZWJ1ZyBsb2dcblxuY29uc3QgY2xpZW50ID0gYXhpb3MuY3JlYXRlKHtcbiAgYmFzZVVSTDogQVBJX1VSTCxcbiAgaGVhZGVyczoge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICB9LFxuICB0aW1lb3V0OiA2MDAwMCwgLy8gNjAgc2Vjb25kIHRpbWVvdXQgKG9wdGltaXphdGlvbiBjYW4gdGFrZSBsb25nZXIpXG59KTtcblxuLy8gQWRkIHJlcXVlc3QgaW50ZXJjZXB0b3IgZm9yIGRlYnVnZ2luZyAob25seSBpbiBkZXYpXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgY2xpZW50LmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcbiAgICAoY29uZmlnKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcIkFQSSBSZXF1ZXN0OlwiLCBjb25maWcubWV0aG9kPy50b1VwcGVyQ2FzZSgpLCBjb25maWcudXJsKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfSxcbiAgICAoZXJyb3IpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBUEkgUmVxdWVzdCBFcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICk7XG5cbiAgLy8gQWRkIHJlc3BvbnNlIGludGVyY2VwdG9yIGZvciBkZWJ1Z2dpbmdcbiAgY2xpZW50LmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXG4gICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcIkFQSSBSZXNwb25zZTpcIiwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5jb25maWcudXJsKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxuICAgIChlcnJvcikgPT4ge1xuICAgICAgLy8gT25seSBsb2cgbm9uLW5ldHdvcmsgZXJyb3JzIGluIGRldGFpbFxuICAgICAgaWYgKGVycm9yLmNvZGUgIT09ICdFUlJfTkVUV09SSycgJiYgZXJyb3IuY29kZSAhPT0gJ0VSUl9DT05ORUNUSU9OX1JFRlVTRUQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBUEkgUmVzcG9uc2UgRXJyb3I6XCIsIGVycm9yLm1lc3NhZ2UsIGVycm9yLnJlc3BvbnNlPy5zdGF0dXMsIGVycm9yLmNvbmZpZz8udXJsKTtcbiAgICAgIH1cbiAgICAgIC8vIEV4dHJhY3QgZXJyb3IgbWVzc2FnZSBmcm9tIHJlc3BvbnNlIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWwpIHtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlsO1xuICAgICAgfSBlbHNlIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSkge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gZXJyb3IucmVzcG9uc2UuZGF0YS5tZXNzYWdlO1xuICAgICAgfSBlbHNlIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzVGV4dCkge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gYCR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvci5yZXNwb25zZS5zdGF0dXNUZXh0fWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IGFwaSA9IHtcbiAgLy8gRGFzaGJvYXJkXG4gIGFzeW5jIGdldERhc2hib2FyZFN0YXRzKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5wb3N0KFwiL3RlYW0vZXZhbHVhdGVcIiwge1xuICAgICAgICBzZWFzb246IFwiMjAyNC0yNVwiLFxuICAgICAgfSwge1xuICAgICAgICB0aW1lb3V0OiAxNTAwMCwgLy8gSW5jcmVhc2UgdGltZW91dCB0byAxNSBzZWNvbmRzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBUEkgRXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIC8vIFJldHVybiBkZWZhdWx0IGRhdGEgb24gbmV0d29yayBlcnJvcnMgaW5zdGVhZCBvZiB0aHJvd2luZ1xuICAgICAgY29uc3QgaXNOZXR3b3JrRXJyb3IgPSBcbiAgICAgICAgZXJyb3IuY29kZSA9PT0gJ0VDT05OQUJPUlRFRCcgfHwgXG4gICAgICAgIGVycm9yLmNvZGUgPT09ICdFUlJfTkVUV09SSycgfHxcbiAgICAgICAgZXJyb3IuY29kZSA9PT0gJ0VSUl9DT05ORUNUSU9OX1JFRlVTRUQnIHx8XG4gICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCd0aW1lb3V0JykgfHxcbiAgICAgICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ05ldHdvcmsgRXJyb3InKSB8fFxuICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJyk7XG4gICAgICBcbiAgICAgIGlmIChpc05ldHdvcmtFcnJvcikge1xuICAgICAgICAvLyBTaWxlbnRseSByZXR1cm4gZGVmYXVsdCBkYXRhIGZvciBuZXR3b3JrIGVycm9yc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNlYXNvbjogXCIyMDI0LTI1XCIsXG4gICAgICAgICAgZ2FtZXdlZWs6IG51bGwsXG4gICAgICAgICAgdG90YWxfcG9pbnRzOiAwLjAsXG4gICAgICAgICAgZXhwZWN0ZWRfcG9pbnRzOiAwLjAsXG4gICAgICAgICAgcmlza19zY29yZTogMC41LFxuICAgICAgICAgIGZpeHR1cmVfZGlmZmljdWx0eTogMy4wLFxuICAgICAgICAgIHNxdWFkX3ZhbHVlOiAwLjAsXG4gICAgICAgICAgYmFuazogMTAwLjAsXG4gICAgICAgICAgcGxheWVyczogW10sXG4gICAgICAgICAgY2FwdGFpbl9pZDogbnVsbCxcbiAgICAgICAgICB2aWNlX2NhcHRhaW5faWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgLy8gVGVhbVxuICBhc3luYyBldmFsdWF0ZVRlYW0oZGF0YToge1xuICAgIHNlYXNvbjogc3RyaW5nO1xuICAgIHRlYW1faWQ/OiBudW1iZXI7XG4gICAgc3F1YWRfanNvbj86IGFueTtcbiAgICBnYW1ld2Vlaz86IG51bWJlcjtcbiAgfSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgbG9uZ2VyIHRpbWVvdXQgZm9yIHRlYW0gZXZhbHVhdGlvbiAoMzAgc2Vjb25kcylcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnBvc3QoXCIvdGVhbS9ldmFsdWF0ZVwiLCBkYXRhLCB7XG4gICAgICAgIHRpbWVvdXQ6IDMwMDAwLFxuICAgICAgfSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJUZWFtIGV2YWx1YXRpb24gcmVzcG9uc2U6XCIsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UuZGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgY29uc3QgaXNOZXR3b3JrRXJyb3IgPSBcbiAgICAgICAgZXJyb3IuY29kZSA9PT0gJ0VDT05OQUJPUlRFRCcgfHwgXG4gICAgICAgIGVycm9yLmNvZGUgPT09ICdFUlJfTkVUV09SSycgfHxcbiAgICAgICAgZXJyb3IuY29kZSA9PT0gJ0VSUl9DT05ORUNUSU9OX1JFRlVTRUQnIHx8XG4gICAgICAgIGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCd0aW1lb3V0JykgfHxcbiAgICAgICAgZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ05ldHdvcmsgRXJyb3InKSB8fFxuICAgICAgICBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJyk7XG4gICAgICBcbiAgICAgIGlmIChpc05ldHdvcmtFcnJvcikge1xuICAgICAgICAvLyBSZXR1cm4gcGxhY2Vob2xkZXIgZGF0YSBmb3IgbmV0d29yayBlcnJvcnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3RhbF9wb2ludHM6IDAsXG4gICAgICAgICAgZXhwZWN0ZWRfcG9pbnRzOiAwLFxuICAgICAgICAgIHNxdWFkX3ZhbHVlOiAwLFxuICAgICAgICAgIGJhbms6IDEwMCxcbiAgICAgICAgICBwbGF5ZXJzOiBbXSxcbiAgICAgICAgICBjYXB0YWluX2lkOiBudWxsLFxuICAgICAgICAgIHZpY2VfY2FwdGFpbl9pZDogbnVsbCxcbiAgICAgICAgICB4Z19zY29yZTogMCxcbiAgICAgICAgICByaXNrX3Njb3JlOiAwLjUsXG4gICAgICAgICAgZml4dHVyZV9kaWZmaWN1bHR5OiAzLjAsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE9ubHkgbG9nIG5vbi1uZXR3b3JrIGVycm9yc1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUZWFtIGV2YWx1YXRpb24gZXJyb3IgZGV0YWlsczpcIiwge1xuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgY29kZTogZXJyb3IuY29kZSxcbiAgICAgICAgICByZXNwb25zZTogZXJyb3IucmVzcG9uc2U/LmRhdGEsXG4gICAgICAgICAgc3RhdHVzOiBlcnJvci5yZXNwb25zZT8uc3RhdHVzLFxuICAgICAgICAgIGNvbmZpZzogZXJyb3IuY29uZmlnPy51cmwsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIGFzeW5jIGdldFhHU2NvcmUoZGF0YToge1xuICAgIHNlYXNvbjogc3RyaW5nO1xuICAgIHNxdWFkOiBhbnlbXTtcbiAgICBnYW1ld2Vlaz86IG51bWJlcjtcbiAgfSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnBvc3QoXCIvdGVhbS94Z3Njb3JlXCIsIGRhdGEpO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIC8vIE9wdGltaXphdGlvblxuICBhc3luYyBvcHRpbWl6ZVNxdWFkKGRhdGE6IHtcbiAgICBzZWFzb246IHN0cmluZztcbiAgICBidWRnZXQ6IG51bWJlcjtcbiAgICBleGNsdWRlX3BsYXllcnM/OiBudW1iZXJbXTtcbiAgICBsb2NrX3BsYXllcnM/OiBudW1iZXJbXTtcbiAgICBjaGlwPzogc3RyaW5nO1xuICAgIGhvcml6b25fZ3c/OiBudW1iZXI7XG4gIH0pIHtcbiAgICAvLyBVc2UgbG9uZ2VyIHRpbWVvdXQgZm9yIG9wdGltaXphdGlvbiAoNjAgc2Vjb25kcylcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5wb3N0KFwiL29wdGltaXplL3NxdWFkXCIsIGRhdGEsIHtcbiAgICAgIHRpbWVvdXQ6IDYwMDAwLFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9LFxuXG4gIC8vIFRyYW5zZmVyc1xuICBhc3luYyBnZXRUcmFkZUFkdmljZShkYXRhOiB7XG4gICAgc2Vhc29uOiBzdHJpbmc7XG4gICAgb3V0X3BsYXllcl9pZDogbnVtYmVyO1xuICAgIGluX3BsYXllcl9pZDogbnVtYmVyO1xuICAgIGJ1ZGdldD86IG51bWJlcjtcbiAgfSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnBvc3QoXCIvdHJhZGVzL2FkdmljZVwiLCBkYXRhKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfSxcblxuICAvLyBDb3BpbG90XG4gIGFzeW5jIGFza0NvcGlsb3QoXG4gICAgcXVlc3Rpb246IHN0cmluZyxcbiAgICBvcHRpb25zPzoge1xuICAgICAgY29udmVyc2F0aW9uX2lkPzogbnVtYmVyO1xuICAgICAgdGVhbV9pZD86IG51bWJlcjtcbiAgICAgIHVzZXJfaWQ/OiBudW1iZXI7XG4gICAgICByb3V0ZT86IHN0cmluZztcbiAgICAgIGFwcF9zdGF0ZT86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgfVxuICApIHtcbiAgICBjb25zdCBhcGlVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo4MDAwXCI7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7YXBpVXJsfS9hcGkvdjEvY29waWxvdC9jaGF0YCwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBtZXNzYWdlOiBxdWVzdGlvbixcbiAgICAgICAgICBjb252ZXJzYXRpb25faWQ6IG9wdGlvbnM/LmNvbnZlcnNhdGlvbl9pZCxcbiAgICAgICAgICB0ZWFtX2lkOiBvcHRpb25zPy50ZWFtX2lkLFxuICAgICAgICAgIHVzZXJfaWQ6IG9wdGlvbnM/LnVzZXJfaWQsXG4gICAgICAgICAgcm91dGU6IG9wdGlvbnM/LnJvdXRlIHx8IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICBhcHBfc3RhdGU6IG9wdGlvbnM/LmFwcF9zdGF0ZSB8fCB7fSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvcGlsb3QgZW5kcG9pbnQgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3BpbG90IGVycm9yOlwiLCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfSxcblxuICAvLyBNTCBQcmVkaWN0aW9uc1xuICBhc3luYyBwcmVkaWN0UG9pbnRzKGRhdGE6IHtcbiAgICBwbGF5ZXJfaWRzOiBudW1iZXJbXTtcbiAgICBzZWFzb246IHN0cmluZztcbiAgICBnYW1ld2VlazogbnVtYmVyO1xuICAgIG1vZGVsX25hbWU/OiBzdHJpbmc7XG4gIH0pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5wb3N0KFwiL21sL3ByZWRpY3RcIiwgZGF0YSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH0sXG59O1xuXG4vLyBFeHBvcnQgUGxheWVyIHR5cGVcbmV4cG9ydCB0eXBlIFBsYXllciA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBwb3NpdGlvbjogc3RyaW5nO1xuICB0ZWFtOiBzdHJpbmc7XG4gIHByaWNlOiBudW1iZXI7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn07XG5cbi8vIFN0YW5kYWxvbmUgZnVuY3Rpb246IExpc3QgcGxheWVyc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpc3RQbGF5ZXJzKFxuICBwb3NpdGlvbjogc3RyaW5nLFxuICBvcHRpb25zOiB7XG4gICAgc2Vhc29uPzogc3RyaW5nO1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICAgIG9mZnNldD86IG51bWJlcjtcbiAgICB0ZWFtPzogc3RyaW5nO1xuICAgIHNlYXJjaD86IHN0cmluZztcbiAgfSA9IHt9XG4pOiBQcm9taXNlPHsgcGxheWVyczogUGxheWVyW107IHRvdGFsOiBudW1iZXIgfT4ge1xuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIGlmIChwb3NpdGlvbikgcGFyYW1zLmFwcGVuZChcInBvc2l0aW9uXCIsIHBvc2l0aW9uKTtcbiAgaWYgKG9wdGlvbnMuc2Vhc29uKSBwYXJhbXMuYXBwZW5kKFwic2Vhc29uXCIsIG9wdGlvbnMuc2Vhc29uKTtcbiAgaWYgKG9wdGlvbnMubGltaXQpIHBhcmFtcy5hcHBlbmQoXCJsaW1pdFwiLCBTdHJpbmcob3B0aW9ucy5saW1pdCkpO1xuICBpZiAob3B0aW9ucy5vZmZzZXQpIHBhcmFtcy5hcHBlbmQoXCJvZmZzZXRcIiwgU3RyaW5nKG9wdGlvbnMub2Zmc2V0KSk7XG4gIGlmIChvcHRpb25zLnRlYW0pIHBhcmFtcy5hcHBlbmQoXCJ0ZWFtXCIsIG9wdGlvbnMudGVhbSk7XG4gIGlmIChvcHRpb25zLnNlYXJjaCkgcGFyYW1zLmFwcGVuZChcInNlYXJjaFwiLCBvcHRpb25zLnNlYXJjaCk7XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQuZ2V0KGAvcGxheWVycy8/JHtwYXJhbXMudG9TdHJpbmcoKX1gKTtcbiAgY29uc3QgcGxheWVycyA9IEFycmF5LmlzQXJyYXkocmVzcG9uc2UuZGF0YSkgPyByZXNwb25zZS5kYXRhIDogW107XG4gIHJldHVybiB7XG4gICAgcGxheWVycyxcbiAgICB0b3RhbDogcGxheWVycy5sZW5ndGgsIC8vIEJhY2tlbmQgZG9lc24ndCByZXR1cm4gdG90YWwsIHNvIHdlIHVzZSBhcnJheSBsZW5ndGhcbiAgfTtcbn1cblxuLy8gU3RhbmRhbG9uZSBmdW5jdGlvbjogT3B0aW1pemUgc3F1YWRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvcHRpbWl6ZVNxdWFkKGRhdGE6IHtcbiAgc2Vhc29uOiBzdHJpbmc7XG4gIGJ1ZGdldDogbnVtYmVyO1xuICBleGNsdWRlX3BsYXllcnM/OiBudW1iZXJbXTtcbiAgbG9ja19wbGF5ZXJzPzogbnVtYmVyW107XG4gIGNoaXA/OiBzdHJpbmc7XG4gIGhvcml6b25fZ3c/OiBudW1iZXI7XG4gIGN1cnJlbnRfc3F1YWQ/OiBudW1iZXJbXTtcbn0pIHtcbiAgcmV0dXJuIGFwaS5vcHRpbWl6ZVNxdWFkKGRhdGEpO1xufVxuXG4vLyBTdGFuZGFsb25lIGZ1bmN0aW9uOiBTcXVhZCBzdW1tYXJ5ICh1c2VzIHRlYW0gZXZhbHVhdGlvbiBlbmRwb2ludClcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzcXVhZFN1bW1hcnkoZGF0YToge1xuICBzZWFzb246IHN0cmluZztcbiAgYnVkZ2V0OiBudW1iZXI7XG4gIHhpX2lkczogbnVtYmVyW107XG4gIGJlbmNoX2lkczogbnVtYmVyW107XG59KSB7XG4gIC8vIENyZWF0ZSBzcXVhZF9qc29uIGZyb20geGlfaWRzIGFuZCBiZW5jaF9pZHNcbiAgY29uc3Qgc3F1YWRfanNvbiA9IHtcbiAgICB4aTogZGF0YS54aV9pZHMsXG4gICAgYmVuY2g6IGRhdGEuYmVuY2hfaWRzLFxuICB9O1xuICBcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQucG9zdChcIi90ZWFtL2V2YWx1YXRlXCIsIHtcbiAgICBzZWFzb246IGRhdGEuc2Vhc29uLFxuICAgIHNxdWFkX2pzb24sXG4gIH0pO1xuICBcbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59XG4iXSwibmFtZXMiOlsiYXhpb3MiLCJBUElfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJjb25zb2xlIiwibG9nIiwiY2xpZW50IiwiY3JlYXRlIiwiYmFzZVVSTCIsImhlYWRlcnMiLCJ0aW1lb3V0IiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsImNvbmZpZyIsIm1ldGhvZCIsInRvVXBwZXJDYXNlIiwidXJsIiwiZXJyb3IiLCJQcm9taXNlIiwicmVqZWN0IiwicmVzcG9uc2UiLCJzdGF0dXMiLCJjb2RlIiwibWVzc2FnZSIsImRhdGEiLCJkZXRhaWwiLCJzdGF0dXNUZXh0IiwiYXBpIiwiZ2V0RGFzaGJvYXJkU3RhdHMiLCJwb3N0Iiwic2Vhc29uIiwiaXNOZXR3b3JrRXJyb3IiLCJpbmNsdWRlcyIsImdhbWV3ZWVrIiwidG90YWxfcG9pbnRzIiwiZXhwZWN0ZWRfcG9pbnRzIiwicmlza19zY29yZSIsImZpeHR1cmVfZGlmZmljdWx0eSIsInNxdWFkX3ZhbHVlIiwiYmFuayIsInBsYXllcnMiLCJjYXB0YWluX2lkIiwidmljZV9jYXB0YWluX2lkIiwiZXZhbHVhdGVUZWFtIiwieGdfc2NvcmUiLCJnZXRYR1Njb3JlIiwib3B0aW1pemVTcXVhZCIsImdldFRyYWRlQWR2aWNlIiwiYXNrQ29waWxvdCIsInF1ZXN0aW9uIiwib3B0aW9ucyIsImFwaVVybCIsImZldGNoIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjb252ZXJzYXRpb25faWQiLCJ0ZWFtX2lkIiwidXNlcl9pZCIsInJvdXRlIiwid2luZG93IiwibG9jYXRpb24iLCJwYXRobmFtZSIsImFwcF9zdGF0ZSIsIm9rIiwiRXJyb3IiLCJqc29uIiwiZXJyIiwicHJlZGljdFBvaW50cyIsImxpc3RQbGF5ZXJzIiwicG9zaXRpb24iLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJsaW1pdCIsIlN0cmluZyIsIm9mZnNldCIsInRlYW0iLCJzZWFyY2giLCJnZXQiLCJ0b1N0cmluZyIsIkFycmF5IiwiaXNBcnJheSIsInRvdGFsIiwibGVuZ3RoIiwic3F1YWRTdW1tYXJ5Iiwic3F1YWRfanNvbiIsInhpIiwieGlfaWRzIiwiYmVuY2giLCJiZW5jaF9pZHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});